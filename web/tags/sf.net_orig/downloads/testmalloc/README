

    M A L L O C ( 3 )   P E R F O R M A N C E   T E S T I N G   K I T


Welcome, this kit of two programs will enable you to compare the performance
of a malloc(3)'s very rapidly.  The trace file (LIPF_B64_1.bin.gz) when used
as input to the program TimeMalloc will do 5607044 malloc(3)'s and free(3)'s
of 14 different buffer sizes.  

As of Aug 2002, I have not found a released malloc(3) (Sun, HP, Linux, BSD 
Unix etc.) that executes this sequence of malloc(3)s and free(3)'s in a 
reasonable time (less than 4 seconds).

Quick try it out:

$ gunzip LIPF_B64_1.bin.gz           // unpack binary trace file
$ cc -O3 TimeMalloc.c -o TimeMalloc  // compile test with 'native' malloc
$ TimeMalloc LIPF_B64_1.bin          // Time the malloc/frees

Four (4) seconds is the acceptable run time on a PIII 750Mhz.


To compile the program that makes the binary trace files:

$ cc CaptureMalloc.c -o CaptureMalloc -lJudy

Sorry, you need the "Judy" library. <http://sourceforge.net/projects/judy>

I wrote these programs in desperation, because I was unable to find a malloc
that performed acceptably in the "Judy" environment.  I recently received, 
from the author (Doug Lea), a PROTOTYPE malloc (mymalloc.c) that is very good.
I hope he will finish it and get it accepted as the default malloc in the 
open source community.


The programs work as follows:

$ YourProgramWithOutputTraces  |  CaptureMalloc Trace_out.bin

then to re-play just the malloc activity, times and memory usage:

$ TimeMalloc Trace_out.bin

CaptureMalloc will take a 'malloc' ascii trace input from stdin, then compress
it to a binary file.  It also checks for overlaping memory allocations and will
put a 'measurement marker' (used by TimeMalloc) whenever the trace contains 
something it does not recoginize as a trace record.  And writes it to stdout,
so you can take a look at it.  Usually it is just stuff the test program 
generated and wrote to stdout. 

TimeMalloc will input the binary file generated by CaptureMalloc and 're-play'
the exact sequences of malloc, free, calloc and realloc that were in the 
origional ascii trace file.  It was designed to have as little overhead as
possible, so even a single malloc or free can be accurately timed.

Do not forget to compile TimeMalloc.c with the malloc.[co] you want to test or
compare.

The small (21Mb) 'LIPF_B64_1.bin' file seems to trip up most mallocs.  It was
generated by a real (well actually a benchmark of Judy) application.  It is too
small to give the OK to a malloc that runs under 4 seconds.  But, if it runs 
over 10 seconds, you should be concerned.  I am currently testing (a prototype
malloc) on a 1Ghz IPF 48Gbyte machine, looking for unacceptable performance 
cases (thank you HP for the loan).

The file 'testdatamalloc.tar.gz' contains enough stuff to produce the trace
file (for my future reference), but I have not documented how to do it.

Doug Baskins <doug@sourcejudy.com>
